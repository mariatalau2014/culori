<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zip Folder Selector</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- JSZip Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- Fontsource Inter -->
    <link href="https://cdn.jsdelivr.net/npm/fontsource-inter@4.5.8/index.css" rel="stylesheet">
    
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }

        /* Tree View Styles */
        .tree-item {
            cursor: pointer;
            user-select: none;
        }
        .tree-item:hover {
            background-color: #f3f4f6;
        }
        .tree-item.selected {
            background-color: #eff6ff;
            color: #1d4ed8;
        }
        .tree-indent {
            width: 1.25rem;
            display: inline-block;
        }
        
        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: transparent; 
        }
        ::-webkit-scrollbar-thumb {
            background: #d1d5db; 
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #9ca3af; 
        }

        .fade-in {
            animation: fadeIn 0.3s ease-in-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden text-gray-800">

    <!-- Header -->
    <header class="bg-white border-b border-gray-200 h-16 flex items-center justify-between px-6 shrink-0 z-10 shadow-sm">
        <div class="flex items-center gap-3">
            <div class="bg-blue-600 text-white p-2 rounded-lg">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z" />
                </svg>
            </div>
            <h1 class="text-xl font-bold text-slate-800 tracking-tight">Zip Explorer</h1>
        </div>
        <div class="flex items-center gap-4">
             <label for="fileInput" class="cursor-pointer bg-white border border-gray-300 hover:bg-gray-50 text-gray-700 font-medium py-2 px-4 rounded-lg transition-colors flex items-center gap-2 text-sm shadow-sm">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
                </svg>
                <span id="uploadLabel">Încarcă ZIP</span>
            </label>
            <input type="file" id="fileInput" accept=".zip" class="hidden">
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-grow flex overflow-hidden">
        
        <!-- Sidebar: File Tree -->
        <aside class="w-80 bg-white border-r border-gray-200 flex flex-col shrink-0 transition-all duration-300" id="sidebar">
            <div class="p-4 border-b border-gray-100 bg-gray-50">
                <h2 class="text-xs font-semibold text-gray-500 uppercase tracking-wider">Structură Fișiere</h2>
            </div>
            <div id="treeContainer" class="flex-grow overflow-y-auto p-2">
                <div class="flex flex-col items-center justify-center h-full text-gray-400 text-center p-4">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 mb-3 opacity-50" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" />
                    </svg>
                    <p class="text-sm">Încarcă un fișier ZIP pentru a vedea structura.</p>
                </div>
            </div>
        </aside>

        <!-- Right Panel: Preview & Actions -->
        <section class="flex-grow flex flex-col bg-slate-50 relative">
            
            <!-- Empty State / Welcome -->
            <div id="emptyState" class="absolute inset-0 flex flex-col items-center justify-center text-gray-400 z-0">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-20 w-20 mb-4 opacity-20" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" />
                </svg>
                <p class="text-lg font-medium">Selectează un folder din stânga</p>
                <p class="text-sm mt-1">Conținutul va fi afișat aici.</p>
            </div>

            <!-- Content Area (Hidden initially) -->
            <div id="contentArea" class="hidden flex-col h-full z-10 fade-in">
                
                <!-- Toolbar -->
                <div class="h-14 bg-white border-b border-gray-200 flex items-center justify-between px-6 shrink-0 shadow-sm">
                    <div class="flex items-center gap-2 overflow-hidden">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-blue-500 shrink-0" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" />
                        </svg>
                        <span id="selectedPathDisplay" class="font-mono text-sm font-medium text-gray-700 truncate" title="">...</span>
                    </div>
                    <div class="flex items-center gap-2 shrink-0">
                        <button id="copyBtn" class="p-2 text-gray-500 hover:text-blue-600 hover:bg-blue-50 rounded-md transition-colors" title="Copiază tot">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                            </svg>
                        </button>
                        <button id="downloadBtn" class="p-2 text-gray-500 hover:text-green-600 hover:bg-green-50 rounded-md transition-colors" title="Descarcă .txt">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                            </svg>
                        </button>
                    </div>
                </div>

                <!-- Text Output -->
                <div class="flex-grow relative bg-white">
                    <textarea id="outputArea" class="w-full h-full p-6 font-mono text-sm text-gray-700 resize-none focus:outline-none leading-relaxed" readonly placeholder=""></textarea>
                    
                    <!-- Stats Overlay -->
                    <div class="absolute bottom-4 right-6 bg-gray-800 text-white text-xs px-3 py-1.5 rounded-full shadow-lg opacity-80 pointer-events-none flex gap-3">
                        <span id="fileCountStat">0 fișiere</span>
                        <span class="w-px h-3 bg-gray-600"></span>
                        <span id="charCountStat">0 caractere</span>
                    </div>
                </div>
            </div>

        </section>
    </main>

    <script>
        const fileInput = document.getElementById('fileInput');
        const uploadLabel = document.getElementById('uploadLabel');
        const treeContainer = document.getElementById('treeContainer');
        const emptyState = document.getElementById('emptyState');
        const contentArea = document.getElementById('contentArea');
        const selectedPathDisplay = document.getElementById('selectedPathDisplay');
        const outputArea = document.getElementById('outputArea');
        const copyBtn = document.getElementById('copyBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const fileCountStat = document.getElementById('fileCountStat');
        const charCountStat = document.getElementById('charCountStat');

        let zipObject = null;
        let flatFileList = []; // Stores {name, path, dir}

        // Handle File Upload
        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            uploadLabel.textContent = "Se încarcă...";
            treeContainer.innerHTML = '<div class="p-4 text-center text-sm text-gray-500">Se procesează arhiva...</div>';

            try {
                const zip = new JSZip();
                zipObject = await zip.loadAsync(file);
                
                flatFileList = [];
                zipObject.forEach((relativePath, zipEntry) => {
                    flatFileList.push({
                        name: zipEntry.name.split('/').pop(),
                        path: relativePath,
                        dir: zipEntry.dir
                    });
                });

                uploadLabel.textContent = file.name;
                renderTree();
                
            } catch (err) {
                alert("Eroare la citirea ZIP: " + err.message);
                uploadLabel.textContent = "Încarcă ZIP";
                treeContainer.innerHTML = '';
            }
        });

        // Render Tree Logic
        function renderTree() {
            treeContainer.innerHTML = '';
            
            // Build a nested structure
            const root = {};
            
            flatFileList.forEach(item => {
                const parts = item.path.split('/');
                let current = root;
                
                parts.forEach((part, index) => {
                    if (!current[part]) {
                        current[part] = {
                            _isDir: index < parts.length - 1 || item.dir,
                            _fullPath: parts.slice(0, index + 1).join('/'),
                            _children: {}
                        };
                    }
                    current = current[part]._children;
                });
            });

            // Recursive render function
            function createTreeElement(node, level = 0) {
                const fragment = document.createDocumentFragment();
                const entries = Object.entries(node).sort((a, b) => {
                    // Folders first, then files
                    if (a[1]._isDir === b[1]._isDir) return a[0].localeCompare(b[0]);
                    return a[1]._isDir ? -1 : 1;
                });

                entries.forEach(([name, data]) => {
                    const el = document.createElement('div');
                    el.className = `tree-item flex items-center py-1.5 px-2 rounded-md text-sm mb-0.5 select-none`;
                    if (data._isDir) {
                        el.style.fontWeight = "500";
                    } else {
                        el.classList.add('text-gray-600');
                    }
                    
                    // Indentation
                    const indentSpan = document.createElement('span');
                    indentSpan.className = 'tree-indent';
                    indentSpan.style.width = (level * 1.25) + 'rem';
                    el.appendChild(indentSpan);

                    // Icon
                    const iconSvg = data._isDir 
                        ? `<svg class="w-4 h-4 mr-2 text-yellow-500" fill="currentColor" viewBox="0 0 20 20"><path d="M2 6a2 2 0 012-2h5l2 2h5a2 2 0 012 2v6a2 2 0 01-2 2H4a2 2 0 01-2-2V6z"/></svg>`
                        : `<svg class="w-4 h-4 mr-2 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/></svg>`;
                    
                    const iconContainer = document.createElement('span');
                    iconContainer.innerHTML = iconSvg;
                    el.appendChild(iconContainer);

                    // Name
                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = name;
                    el.appendChild(nameSpan);

                    // Click Event for Folders
                    if (data._isDir) {
                        el.addEventListener('click', (e) => {
                            e.stopPropagation();
                            // Highlight logic could go here if we wanted multi-select, 
                            // but for now we just trigger the load
                            loadFolderContent(data._fullPath);
                            
                            // Visual selection feedback
                            document.querySelectorAll('.tree-item').forEach(i => i.classList.remove('selected', 'bg-blue-50'));
                            el.classList.add('selected', 'bg-blue-50');
                        });
                    }

                    fragment.appendChild(el);

                    // Recurse children
                    if (Object.keys(data._children).length > 0) {
                        const childrenContainer = createTreeElement(data._children, level + 1);
                        fragment.appendChild(childrenContainer);
                    }
                });

                return fragment;
            }

            treeContainer.appendChild(createTreeElement(root));
        }

        // Load Folder Content
        async function loadFolderContent(folderPath) {
            // Ensure path ends with slash for matching, unless it's root
            const prefix = folderPath.endsWith('/') ? folderPath : folderPath + '/';
            
            // Filter files that start with this prefix
            const filesInFolder = flatFileList.filter(f => 
                !f.dir && // Only files
                (f.path.startsWith(prefix) || f.path === folderPath) && // Inside folder
                f.path !== folderPath // Not the folder itself
            );

            if (filesInFolder.length === 0) {
                outputArea.value = "// Acest folder este gol sau conține doar sub-foldere.";
                fileCountStat.textContent = "0 fișiere";
                charCountStat.textContent = "0 caractere";
            } else {
                processFiles(filesInFolder);
            }

            // Update UI
            emptyState.classList.add('hidden');
            contentArea.classList.remove('hidden');
            contentArea.classList.add('flex');
            selectedPathDisplay.textContent = folderPath || "/ (Root)";
        }

        async function processFiles(files) {
            outputArea.value = "Se încarcă conținutul...";
            let fullText = "";
            let count = 0;

            const promises = files.map(async (file) => {
                try {
                    const content = await zipObject.file(file.path).async("string");
                    count++;
                    fullText += `\n\n/* =========================================\n   FILE: ${file.path}\n   ========================================= */\n\n`;
                    fullText += content;
                    fullText += `\n\n/* =========================================\n   END OF FILE\n   ========================================= */\n`;
                } catch (e) {
                    console.warn(`Could not read ${file.path}, likely binary.`);
                }
            });

            await Promise.all(promises);

            outputArea.value = fullText.trim() || "Nu s-a putut extrage text din fișierele acestui folder (posibil binare).";
            fileCountStat.textContent = `${count} fișiere`;
            charCountStat.textContent = `${fullText.length} caractere`;
        }

        // Copy Functionality
        copyBtn.addEventListener('click', () => {
            if (!outputArea.value) return;
            navigator.clipboard.writeText(outputArea.value).then(() => {
                const originalHtml = copyBtn.innerHTML;
                copyBtn.innerHTML = `<svg class="h-5 w-5 text-green-600" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/></svg>`;
                setTimeout(() => {
                    copyBtn.innerHTML = originalHtml;
                }, 2000);
            });
        });

        // Download Functionality
        downloadBtn.addEventListener('click', () => {
            if (!outputArea.value) return;
            const blob = new Blob([outputArea.value], { type: "text/plain;charset=utf-8" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            // Generate filename from selected folder
            const folderName = selectedPathDisplay.textContent.replace(/\//g, '_') || 'export';
            a.download = `${folderName}_concatenated.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

    </script>
</body>
</html>

